package org.zaproxy.addon.naf.ui.exploit

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.MaterialTheme.typography
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.KeyboardArrowUp
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import me.d3s34.sqlmap.restapi.TaskDataContentType
import me.d3s34.sqlmap.restapi.data.ListStringData
import me.d3s34.sqlmap.restapi.data.MapStringListStringData
import me.d3s34.sqlmap.restapi.data.StringData
import me.d3s34.sqlmap.restapi.data.TargetData
import me.d3s34.sqlmap.restapi.data.DumpTableData
import me.d3s34.sqlmap.restapi.request.StartTaskRequest
import me.d3s34.sqlmap.restapi.response.TaskDataResponse
import org.zaproxy.addon.naf.component.exploit.SqlmapTabComponent
import org.zaproxy.addon.naf.ui.wizard.LabelCheckBox
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths


@Composable
fun SqlExploitTab(
    startTaskRequest: MutableState<StartTaskRequest>,
    response: State<TaskDataResponse?>,
    status: State<SqlmapTabComponent.Status>,
    csvLocation: String,
    onStartAttack: () -> Unit
) {
    Row {
        Column(
            modifier = Modifier.weight(.5f)
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth(),
                horizontalArrangement = Arrangement.Center
            ) {
                Text(
                    text = "Target",
                    style = typography.subtitle1,
                    fontWeight = FontWeight.Bold
                )
            }

            SqlmapOptions(
                startTaskRequest,
                onStartAttack
            )
        }

        Spacer(Modifier.width(10.dp))

        Column(
            modifier = Modifier.weight(.5f)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Center
            ) {
                Text(
                    text = "Result",
                    style = typography.subtitle1,
                    fontWeight = FontWeight.Bold
                )
            }

            Divider()

            Row(
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                SqlmapResult(response, csvLocation, status)
            }
        }
    }
}

@Composable
fun SqlmapOptions(
    requestAttack: MutableState<StartTaskRequest>,
    onStartAttack: () -> Unit
) {

    val scrollState = rememberScrollState(0)

    with(requestAttack) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .verticalScroll(scrollState)
        ) {
            OutlinedTextField(
                value = value.url ?: "",
                onValueChange = { value = value.copy(url = it) },
                label = { Text("Target") },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true,
            )

            OutlinedTextField(
                value = value.data ?: "",
                onValueChange = { value = value.copy(data = it) },
                label = { Text("Data") },
                modifier = Modifier.fillMaxWidth(),
            )

            OutlinedTextField(
                value = value.cookie ?: "",
                onValueChange = { value = value.copy(cookie = it) },
                label = { Text("Cookies") },
                modifier = Modifier.fillMaxWidth(),
            )

            LabelCheckBox(
                checkedState = value.randomAgent,
                onCheckedChange = {
                    value = value.copy(randomAgent = it)
                },
                text = "Random Agent"
            )

            Divider()

            LabelCheckBox(
                checkedState = value.getHostname,
                onCheckedChange = {
                    value = value.copy(getHostname = it)
                },
                text = "Get hostname"
            )

            LabelCheckBox(
                checkedState = value.getCurrentUser,
                onCheckedChange = {
                    value = value.copy(getCurrentUser =  it)
                },
                text = "Get Current User"
            )

            LabelCheckBox(
                checkedState = value.getCurrentDb,
                onCheckedChange = {
                    value = value.copy(getCurrentDb = it)
                },
                text = "Get Current DB"
            )

            Divider()

            LabelCheckBox(
                checkedState = value.getDbs,
                onCheckedChange = {
                    value = value.copy(getDbs = it)
                },
                text = "Get all Dbs"
            )

            LabelCheckBox(
                checkedState = value.getTables,
                onCheckedChange = {
                    value = value.copy(getTables = it)
                },
                text = "Get all Table"
            )

/*            LabelCheckBox(
                checkedState = value.getColumns,
                onCheckedChange = {
                    value = value.copy(getColumns = it)
                },
                text = "Get all Columns"
            )

            Divider()

            val execSql = remember { mutableStateOf(false) }

            LabelCheckBox(
                checkedState = execSql.value,
                onCheckedChange = {
                    execSql.value = it
                },
                text = "Exec SQL query"
            )

            if (execSql.value) {
                OutlinedTextField(
                    value = value.sqlQuery ?: "",
                    onValueChange = {
                        value = value.copy(sqlQuery = it)
                    },
                    label = {
                        Text("Sql query")
                    },
                    modifier = Modifier.fillMaxWidth()
                )
            }*/

            Divider()

            LabelCheckBox(
                checkedState = value.dumpTable,
                onCheckedChange = {
                    value = value.copy(dumpTable = it)
                },
                text = "Dump table"
            )

            Divider()

            val dbCheck = remember { mutableStateOf(value.db != null) }

            LabelCheckBox(
                checkedState = dbCheck.value,
                onCheckedChange = {
                    dbCheck.value = it
                },
                text = "Database"
            )
            if(dbCheck.value) {
                OutlinedTextField(
                    value = value.db ?: "",
                    onValueChange = { value = value.copy(db = it) },
                    label = { Text("Database") },
                    modifier = Modifier.fillMaxWidth(),
                )
            } else {
                value = value.copy(db = null)
            }

            val tblCheck = remember { mutableStateOf(value.tbl != null) }

            LabelCheckBox(
                checkedState = tblCheck.value,
                onCheckedChange = {
                    tblCheck.value = it
                },
                text = "Table"
            )
            if(tblCheck.value) {
                OutlinedTextField(
                    value = value.tbl ?: "",
                    onValueChange = { value = value.copy(tbl = it) },
                    label = { Text("Table") },
                    modifier = Modifier.fillMaxWidth(),
                )
            } else {
                value = value.copy(tbl = null)
            }

            val colCheck = remember { mutableStateOf(value.col != null) }

            LabelCheckBox(
                checkedState = colCheck.value,
                onCheckedChange = {
                    colCheck.value = it
                },
                text = "Column"
            )

            if(colCheck.value) {
                OutlinedTextField(
                    value = value.col ?: "",
                    onValueChange = { value = value.copy(col = it) },
                    label = { Text("Column") },
                    modifier = Modifier.fillMaxWidth(),
                )
            } else {
                value = value.copy(col = null)
            }

            Divider(Modifier.width(10.dp))

            Row {
                Button(
                    onClick = onStartAttack
                ) {
                    Text("Start Attack")
                }
            }
        }
    }
}

@Composable
fun SqlmapResult(
    response: State<TaskDataResponse?>,
    csvLocation: String,
    status: State<SqlmapTabComponent.Status>,
) {
    Column {
        Row {
            Text(
                text = "Status",
                style = typography.subtitle1,
                fontWeight = FontWeight.Bold
            )
            Spacer(Modifier.width(20.dp))
            @Suppress("Deprecation")
            Text(status.value.name.lowercase().capitalize())
        }

        Divider()

        Column(
            modifier = Modifier.fillMaxWidth()
        ) {
            when (status.value) {
                SqlmapTabComponent.Status.RUNNING -> {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth(),
                        horizontalArrangement = Arrangement.Center
                    ) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(50.dp)
                        )
                    }
                }
                SqlmapTabComponent.Status.DONE -> {
                    val responseValue = response.value

                    if (responseValue == null || responseValue.data.isNullOrEmpty()) {
                        Text(
                            text = "Can not attack",
                            style = typography.h2,
                            fontWeight = FontWeight.Bold,
                            modifier = Modifier.align(Alignment.CenterHorizontally),
                        )
                    } else {
                        DataResponse(responseValue, csvLocation)
                    }
                }
                SqlmapTabComponent.Status.ERROR -> {

                }
                SqlmapTabComponent.Status.NOT_RUN -> {

                }
            }
        }
    }
}

@Composable
fun DataResponse(
    response: TaskDataResponse,
    csvLocation: String
) {

    val scrollState = rememberScrollState(0)
    Column(
        modifier = Modifier
            .verticalScroll(scrollState)
    ) {
        response.data?.forEach { content ->
            Spacer(Modifier.padding(10.dp))

            if (content.status != 1) {
                return@forEach
            }

            when (content.type) {
                TaskDataContentType.TARGET.id -> {
                    val data = content.value as? TargetData ?: return@forEach
                    SqlmapField("Url", data.url)
                    SqlmapField("Query", data.query ?: "")
                    SqlmapField("Data", data.data ?: "")
                    Divider()
                }
                TaskDataContentType.TECHNIQUES.id -> {
//                val data = content.value as? TechniqueData ?: return@forEach
//                Column {
//                    SqlmapField("")
//                }
                }
                TaskDataContentType.HOSTNAME.id -> {
                    val data = content.value as? StringData ?: return@forEach
                    SqlmapField("Hostname", data.value)
                    Divider()
                }
                TaskDataContentType.CURRENT_USER.id -> {
                    val data = content.value as? StringData ?: return@forEach
                    SqlmapField("Current user", data.value)
                    Divider()
                }
                TaskDataContentType.CURRENT_DB.id -> {
                    val data = content.value as? StringData ?: return@forEach
                    SqlmapField("Current DB", data.value)
                    Divider()
                }
                TaskDataContentType.DBS.id -> {
                    val expanded = remember { mutableStateOf(false) }

                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable {
                                expanded.value = !expanded.value
                            }
                    ) {
                        Text("List DBs")

                        if (expanded.value) {
                            Icon(Icons.Default.KeyboardArrowUp, "more")
                        } else {
                            Icon(Icons.Default.KeyboardArrowUp, "more")
                        }
                    }

                    if (expanded.value) {
                        val data = content.value as? ListStringData ?: return@forEach
                        Spacer(Modifier.height(10.dp))
                        data.value.forEach { db ->
                            Text(db)
                        }
                    }

                    Divider()
                }
                TaskDataContentType.TABLES.id -> {

                    val tablesSectionExpanded = remember { mutableStateOf(false) }

                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable {
                                tablesSectionExpanded.value = !tablesSectionExpanded.value
                            }
                    ) {
                        @Suppress("deprecation")
                        Text("List Tables In Database")

                        if (tablesSectionExpanded.value) {
                            Icon(Icons.Default.KeyboardArrowUp, "more")
                        } else {
                            Icon(Icons.Default.KeyboardArrowUp, "more")
                        }
                    }

                    Divider()

                    if (tablesSectionExpanded.value) {
                        val data = content.value as? MapStringListStringData ?: return@forEach
                        val currentDatabase = remember { mutableStateOf(data.value.keys.first()) }
                        val expanded = remember { mutableStateOf(false) }

                        Text(
                            text = "Database",
                            style = typography.subtitle1
                        )

                        Row(
                            modifier = Modifier.fillMaxWidth()
                        ){
                            OutlinedTextField(
                                value = currentDatabase.value,
                                onValueChange = {},
                                trailingIcon = {
                                   IconButton(
                                       onClick = {
                                           expanded.value = true
                                       }
                                   ) {
                                       Icon(Icons.Default.ArrowDropDown, "More")
                                   }
                                },
                                modifier = Modifier.fillMaxWidth()
                            )

                            DropdownMenu(
                                expanded = expanded.value,
                                onDismissRequest = {
                                    expanded.value = false
                                }
                            ) {
                                data.value.keys.forEach { db ->
                                    DropdownMenuItem(
                                        onClick = {
                                            currentDatabase.value = db
                                            expanded.value = false
                                        }
                                    ) {
                                        Text(db)
                                    }
                                }
                            }
                        }

                        Spacer(Modifier.height(10.dp))

                        Column{
                            Text(
                                text = "Table",
                                style = typography.subtitle1
                            )

                            if (data.value.containsKey(currentDatabase.value)) {
                                data.value[currentDatabase.value]?.forEach { table ->
                                    Text(text = table)
                                }
                            }
                        }
                    }

                    Divider()
                }
                TaskDataContentType.COLUMNS.id -> {

                }
                TaskDataContentType.DUMP_TABLE.id -> {
                    var data = content.value as? DumpTableData ?: return@forEach
                    DataTable(data, csvLocation)
                }
                TaskDataContentType.SQL_QUERY.id -> {
                    val expanded = remember { mutableStateOf(false) }

                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable {
                                expanded.value = !expanded.value
                            }
                    ) {
                        Text("Last Query")

                        if (expanded.value) {
                            Icon(Icons.Default.KeyboardArrowUp, "more")
                        } else {
                            Icon(Icons.Default.KeyboardArrowUp, "more")
                        }
                    }

                    Divider()
                }
                else -> {

                }
            }
        }
    }
}

@Composable
fun SqlmapField(
    title: String,
    value: String,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
    ) {
        Text(
            text = title,
            style = MaterialTheme.typography.subtitle2
        )

        Spacer(Modifier.padding(5.dp, 0.dp, 20.dp, 0.dp))

        Text(
            text = value,
            style = MaterialTheme.typography.body1
        )
    }
}

@Composable
fun DataTable(
    data: DumpTableData,
    csvLocation: String
) {
    // val scrollStateHorizontal = rememberScrollState()
    // val scrollStateVertical = rememberScrollState()

    // var maxLength = 0
    // for (String key: data) {
    //     maxLength = Math.max(maxLength, data.get(key).size())
    // }

    // Column(
    //     modifier = Modifier.fillMaxWidth()
    //         .verticalScroll(state = scrollStateVertical)
    //         .horizontalScroll(state = scrollStateHorizontal)
    // ) {
    //     Row {
    //         for(String key: data) {
    //             Text(text = key)
    //         }
    //     }
    //     for (var i = 0;i < maxLength;i++) {
    //         Row {
    //             for(String key: data) {
    //                 Text(text = data.get(key)[i])
    //             }
    //         }
    //     }
    // }
    SqlmapField("Database", data.db)
    SqlmapField("Table", data.table)
    Text(text = data.data.toString())
    val dir = File(csvLocation)
    if (!dir.exists()) {
        dir.mkdirs()
    }
    val csv = File("${csvLocation}/${data.db}-${data.table}.csv")
    val valuesSeparator = ","
    val lineTerminator = "\r\n"
    csv.writeText(data.data.keys.joinToString(separator = valuesSeparator, postfix = lineTerminator))
    val nRows = data.data.values.maxOf {it.size}
    for (i in 0 until nRows) {
        val row = data.data.values.map{
            it.getOrElse(i) {""}
        }.joinToString(separator = valuesSeparator, postfix = lineTerminator)
        csv.appendText(row)
    }
    // saveToCSVFile(data.data, )
}
